Report for the Term Project CSC565 Fall 2015 
Authors (in random order): Samuel Bumgardner, Anton Kostyuchenko, Sean Straus 

I. INTRODUCTION 

WE chose to develop peer-to-peer javascript networking library for game development as our term project. This decision was partially influenced by the fact that two of us were working on a multiplayer web-game last semester and made the mistake of developing  singleplayer mode first, hoping that it would be fairly easy to extend it to multiplayer later. As we very quickly learned, the task was not as simple as we hoped, and the whole project had to face changes in order for multiplayer to be implemented.  Even after that there were multiple desynchronization issues. So this semester we wanted to develop a gaming library that would handle as much of the peculiarities of multiplayer development as possible behind the scenes, and allow game developer to concentrate on their game mechanics instead of hunting down nasty desynchronization bugs in their networking code. The task was not especially easy, and we did not accomplish as much as we hoped. The game still needs to be written in a specific way to be able to incorporate our library, but I still think that we did a fairly good job in hiding as many complexities and imposing as few restrictions as possible on the end user. 

II. STRUCTURE OF THIS REPORT

TODO: fill after the whole project report is done describe what each section will be about 

III. GOALS 

As mentioned above, one of the goals of our project was to hide as much complexity as possible from the developer of the game, but there were other goals and constraints that we tried to keep in mind while developing the library. 
A. Implicit Goals There were of course implicit goals associated with development of any library. 
1) Correctness: One of such goals is correctness, because no one would be interested in using the library which does not operate in predictable and logical fashion. 
2) Efficiency: The other goal typical for  libraries of any kind would be efficiency, as a library is included as part of presumably larger application that may include dozens of other libraries. End users assume that a third-party library will provide a better solution than they could with their available resources (time, effort etc.), and often include them to perform low-level tasks that will be used as a foundation for the logic of their particular product. For this reason a library must be more rigorously optimized than a top-level application. 
B. Other Goals 
1) Extensibility: Besides the aforementioned implicit goals, we intended to write a library that would be easy to extend and improve without changing the existing interface (while new functions can be added without consequence, removal or modification of old functions creates a headache for end users who wish to take advantage of newer versions of the library or may force the library authors to waste space on deprecated functionality in order to ensure backwards compatibility). Such extensions might include allowing more complex functionality, like sharing state only between players that are in the specific territory of the game world. 
2) Low Cost: Final goal was to minimize resource requirements for the developers of the game, so that they do not need to pay excessive money for good servers in different locations of the country and buy large amount of traffic to make their game run smoothly for large numbers of people spread around the world.  This is one of the main justifications for using peer-to-peer networking over the client-server model.  Even though our final solution still requires server for peer match brokering, it is not complex or heavy, and the network performance of the game does not depend on quality of the connection to the server. It is also theoretically possible to use only free services to have the server running, although this can be tricky, as we explain in the section dedicated to resource usage specifically. 

IV. INTERFACE 

Before we describe the details of the implementation, it seems best to explain the interface that will be presented to users of the library, as this provides a top-down view of the overall structure of the library. This includes all of the functions that the developer will call and the parameters that the developer can pass to the library to change its behavior. The current interface of the library consists of 5 functions: • init(update_function, options_object) • submit_frame(state, user_inputs) • random() • get_peers() • get_info() A. Init function The init function takes update function as it’s first parameter, and options object as it’s second parameter. 1) Update Function: Update function is the gamedeveloper-written function that accepts two parameters: state and user inputs. State is expected to be object nested to arbitrary depth, and will contain the state of the game that is already synchronized between peers (so for the given frame, update function will be called with exactly same state on every peer in the network). Input is going to be javascript object with each key corresponding to ID of one of the peers in the network, and value being representation of the player input 2 (keyboard input, mouse input etc.) in the developer specified format. Update function is going to be responsible for fully simulating and processing the game step, including reading state object to draw the graphics output to the screen, running the game physics simulation (if any) using the data from the state object, updating the state with correspondence to player inputs and the results of the physics simulation etc. When the update function will be done, it’s going to call the submit_frame function, which will be discussed later. If you are wandering why the update function is passed as callback function, instead of just allowing the developer to call some function from the library to get state and input, this is closely related to how javascript and networking library that we used as part of our implementation work, and it will be discussed in the Design of The Library section. 2) Options Object: Options object allows the developer to pass options and settings to the library. Doing it with the javascript object as opposed to simple parameter list allows support for virtually unlimited number of named parameters, optionally nested to the arbitrary depth, which makes it extremely easy to introduce new options, since it does not going to break any older code, unless defaults aren’t provided for new options. Such organization also makes it very easy to organize options hierarchically, which can be very helpful as number of available options grows. Currently there are only two recognized options, server_info and log_level. Server info is  another object with three keys: host, port, and path which allow developer to specify the parameters needed to connect to the server which will be brokering connections between peers. The default values for server info members are the parameters necessary to work with local testing server instance that ships with the library, which allows easy local testing for the game developer. Log level can be integer 0, 1 or 2, for info, warning, and error respectively that allows developer to specify what messages they want to see in the browser console (the default is warning). B. Submit Frame Function Submit frame function takes two objects, state and user input. It is supposed to be called at the end of the frame simulation step inside the game developer’s update function. 1) State: As mentioned previously, state is javascript object nested to the arbitrary depth, containing game developer’s representation of the game state. In this particular case this object was passed to the game developer’s update function, presumably manipulated in accordance with user inputs and game rules, and now needs to be synchronized between all peers, before it can be passed to update function for the simulation of the next frame. 2) User Input: User input can be any javascript object, whether primitive (e.g. integer), array, or plain arbitrary javascript object with any number of key-value pairs and nested to arbitrary depth. This object is supposed to represent the input for the current peer for the next frame. It is done this way so that library has a chance to send this input to all other peers, and receive input of other players before next frame. Before the next frame, library will package this object along with all other input objects into the user inputs object and pass it to the update function for use during simulation of the next frame. C. Random Random function is supposed to be drop-in replacement for the javascript Math.random() function, with the only difference being that it is guaranteed to generate the same sequence of random numbers across all peers in the network. Developers are highly recommended to use this function for as many random decisions during frame simulation as possible. This will help to ensure that inconsistencies in the state of the game are as small as possible, so they are easier for the networking library to resolve. It is the unfortunate fact that the developer does not always have complete control of how random decisions are made in their game (e.g. if they are using third-party physics engine that has it’s own random number generator), but it is OK, since the library does provide efficient mechanism for resolving relatively small desynchronizations that are typical for the randomizations that can be introduced during physics simulation or other non-developer-controller factors, such as different handling of floating point rounding on different architectures. The library can even resolve large desynchronizations, provided that they do not occur often, and affect only small percentage of peers at any given time. D. Get Peers This is fairly straightforward function that simply returns list of peer ID’s of all peers participating in the current game. There is one important property to it, though: peer ID array that it returns is guaranteed to be in the same order on every peer in the network, which enables developer to use it for assigning priority or order to otherwise equal peers, which may provide useful in some cases, such as establishing order of moves in the board game etc. E. Get Info Get info function returns javascript object with certain information about state of the library. This function is provided mainly for debugging and analysis, although there could be other uses to it in the future, when more information is available. This function is of course easily extensible, since the only thing that is needed to return more information is to add the key to the returned object, attaching whatever private piece of information needs to be returned. V. THIRD PARTY LIBRARIES We are now almost ready to dive into the details of implementation of the library. Before we do that, however, it is necessary to mention the third party libraries that our library uses to implement its functionality. 3 A. Peerjs The most important by far is the peerjs library, that builds on top of the WebRTC technology to provide peer-to-peer data and media streams with easy to use API. It has extensive functionality, is highly configurable and new functionality is still being added in, but we use only its simple and stable peerto-peer data channels in this library. We also use brokering server implementation that they provide, with some minor additions on top of it to accommodate for needs of our library. Both peerjs and peerjs-server are provided uner MIT license. B. JSON Stable Stringify json-stable-stringify library is almost identical to built-in javascript JSON.stringify function, except it is guaranteed to produce the same exact stringification for the same exact object no matter how the object was created and what platform code runs on. This is important to us because we compare game states in serialized state, using string scoring algorithm, which could of course show massive differences for equivalent objects, if they would not be stringified consistently. C. String Score We also use string_score function to compare serialized states. In our experience this scoring function is not very accurate (may show 95% similarity for exact same strings) but is pretty precise (differences of similar magnitude provide similar score). The main reason the library was chosen is because of it’s outstanding performance (it’s able to make hundreds of comparisons per second), and because it’s “good enough” for our purposes, since high accuracy is not as important for our particular use case. D. Other libraries There are other libraries we use, like jquery, which does not play instrumental role in the library itself, but provides some useful functionality for quick testing during development. There is browserify, that allows to use node-style require statement, and then compile the source and required libraries into single javascript file so that it can be easily included into the webpage. There is not much to say about them except that we use them in correspondence with what their respective licenses permit. 

VI. DESIGN OF THE LIBRARY 

In this section we will give a detailed overview of how the library operates. We decided that the best way to present this overview is to first follow the typical operation cycle, from the very first library function that is called by the developer up to the moment the first synchronization of the game state completes. We will look at which functions are called and under what conditions, as well as what those functions do and the reasons the code is organized like that. 
A. Init Function The library operation starts in the init function. As described above, this function takes an update function as the first parameter and options object as the second. The init function does two things: initial configuration of the library and peer creation. Initial configuration is pretty trivial. The init function reads options object and sets internal variables of the library to the corresponding values, if the given properties are present in the options, if certain property is not present, it is set to the default value. The value of the updat function parameter is assigned to the global variable, so that update function can be called whenever needed. Peer creating is almost as trivial. Peer object is created using peerjs library function and event listeners are set up for the “open” and “error” events. When the peer object is created, it is passed server information as parameters. Peerjs library contacts the server, requests peer id from it, when it receives response, it produces the “open” event if the retrieval of id succeeded. 
B. Init Second Stage Function When “open” event occurs, this function is called and is passed the id of the newly created peer. The function sets up listeners for the rest of the events: “close”, “connection” and “disconnected”. Than it sets up timeout function to call find_peers_and_connect after certain interval, typically 5 to 15 seconds, which is needed due to delay in the peer registering mechanism in our server implementation. C. Find Peers and Connect TODO: finish it and the rest of the function descriptions in the chain. 

VII. MORE ON EFFICIENCY

A. Current State
In its current state, our library is focused on reliability as opposed to efficiency. Because of our lack of experience with peer-to-peer networking, we wished to proceed cautiously and base future improvements on reliable foundations. As such, certain protocols used for synchronizing the game state and establishing information were made robust at the expense of computation time. This is true of our popularity-contest method of determining a canonical game-state, which involves a complex system of comparing the stringified game-states against each other. While this is manageable with a small number of peers, in its current state it may not be feasible for games involving a large number of peers.
B. Challenges 
Beyond simply using good coding practices, improvements in performance generally come at the expense of either security or reliability. The more redundant information is distributed over a network and the more handshaking is done by various peers, the more likely a given peer will end up with the right information. However, these things are not free, and come at the expense of computing time, lag, and bandwidth usage. To make matters worse, javascript is a very slow language, and even a small amount of lag can be fatal in many videogames. To my knowledge, the members of this team have little experience with online security systems, but it seems probable that a well-secured algorithm that protects the game state from cheaters and hackers would create additional overhead. Lastly, the fact that this library is to be used so generally means that we cannot make many assumptions about the context. What is suitable for online chess may not be for a first-person shooter or fighting game and so on. Every game will make different demands on different parts of the system, and we must find ways to account for all of them without cluttering up the interface with hundreds of options and settings which may be useless or unintelligible to a large portion of our users.
C. Possible Improvements 
A number of improvements have been proposed, though they proved to be outside the scope of the semester. Briefly, they fall into three categories: algorithm optimization, resource management, and network optimization. Algorithm optimization would involve modification or replacement of existing algorithms for synchronization and identification to reduce time complexity. To reuse the popularity contest example, a suitable mathematical model of the string-differences of the various gamestates might reveal a shortcut to determining the mean without having to manually compare them all against each other. We have discussed various forms of prediction caches to help guess which parts of the gamestate are unlikely to change and leave them out of calculations, or calculate them less often. Breaking the states to be compared into smaller pieces may also increase performance in some cases, especially if prediction were implemented. 
Resource management would involve the use of under-used resources to relieve the burden of over-used resources. For instance, if the internet connection is slow, the library may switch over to a less reliable version of an algorithm in order to avoid RTT delays. Similarly packets may be reorganized, sending larger packets less frequently or smaller packets with greater frequency to accommodate changes in the system where detected. In most cases, the library could be optimized to make better use of the peers’ combined processing power to compensate for the inherent slowness of the network. 
The greatest improvement to this library, however, would come from network optimization. One of the inherent advantages of peer-to-peer networking is that the burden of processing and data storage can be made to scale with the number of peers. This was one of the primary motivations of the project, but due to the complexity of the task we were unable to achieve this during the semester. Network optimization, in this case, would mean breaking down a large network into smaller sub-networks. One system we researched heavily, Vorogame, was designed for use in massively multiplayer games, and as such was built to take advantage of the scalability of peer-to-peer networks. Vorogame uses the voronoi system of data distribution based on Area of Interest (AOI). A peer is given responsibility for disseminating data about changes made to a certain set of data that is relevant to himself. This is easily visualized in a game where each peer has visibility over a geometrical area within the game world, but could be applied to any data that is immediately accessible or modifiable by the peer. A distributed hashtable is maintained which allows a peer to easily look up which peers hold data which he wishes to access. In addition, each peer maintains a list of directly adjacent peers and indirectly adjacent peers. An implementation of some variant of this system could be used to manage the overhead involved in synchronizing large numbers of game states. The primary difficulty we encountered in such an implementation is that it would have to be generalized for any game without requesting detailed information from the end user. 

VIII. MORE ON EXTENSIBILITY

 A. Current State 
From the beginning of the project, we focused on building an open framework rather than the details of any single implementation. This means that our library should be fairly extensible. However, with only half a semester of development, it is hard to say whether this would hold up in the future
B. Challenges 
One of the persistent challenges in building an extensible system is that of prediction. It is hard to balance the trouble of generalizing something now and needing that generalization later. However, in this instance, our top priority with this regards was to ensure that the core interface would never require alteration, and that any modifications could be handled at a lower level. That having been said, it seems to me that our greatest challenge derives from the fact that it is very difficult to predict the sort of demands placed on a networking library by an online videogame. There are many kinds of games, and most existing games rely on hand-crafted packets to keep in sync rather than generalized game-state parsers. To attempt to properly account for everything these games might require without massive overhead can be tricky at times.
C. Possible Improvements
Maintaining extensibility is an ongoing process. At the current point in development, painting ourselves into a corner is not really a pressing concern. However, there is definitely room for further generalization in our algorithms, if not in our framework. However, this was anticipated, and intentional, since our primary goal was to get something functional and reliable to work off of in the future. 

IX. MORE ON LOWERING THE COST FOR THE GAME DEVELOPER 
A. Current State 
In its current state, our library is extremely lightweight. We have successfully hosted and run our demonstration program off of heroku, a service that offers free temporary hosting. This is possible because the existing system only uses the server for extremely basic tasks, such as assigning ids to peers as they log on and initializing the program. Of course, an actual game developer may wish to store additional data or run additional programs on his server, but the presence of our library on a server is currently negligible. Needless to say, our project is on a public bitbucket repository so anyone who likes can go and download it for free.
B. Challenges 
Taking expensive and complicated servers out of the equation as much as possible is one of the two primary motivations for the use of a peer-to-peer network. To a certain extent, any free networking library that saves the time, money, and/or labor of getting networking capabilities by some other route is itself a way of lowering the costs of the end user.
C. Possible Improvements 
Its difficult to say how we could do more with just a library. Over a local area network, it would actually be free, and as mentioned earlier, some free services will allow the user to host a simple program using our library free of charge. 

X. OUR EXAMPLE: MULTIPLAYER 2048 GAME 
To demonstrate that our library is actually functional, we took an open-source (It’s under MIT license) game called 2048 from  github, and modified it using our library, so that it allows multiple players to play on the same board. 4 

XI. MODULARIZATION 
It is worth while to note that the library as it stands is not split into different files and/or “classes” which is, in our opinion, a reasonable approach for a relatively small ( < 1000 lines of code) javascript library. If the library were to grow to a larger size, it could always be modularized using tools like browserify, which compile multiple javascript source files into single file that can be included into the web page, but we feel that at this point the burden of incorporating modularization approaches taken by such tools would only introduce unnecessary overhead, without providing substantial benefits (two members of our team actually have good amount of experience with some of these tools, since we wrote highly modularized javascript game last semester). We also want to note, that the library is compiled using browserify at this time, but this is only done to allow easy inclusion of various libraries through npm, and the library itself does not utilize any modularization mechanisms except require statements. 

XII. DOCUMENTATION 
All current documentation is done inline within library sources (such as comments to public functions), and in the Interface section of this report, which seems to us to be enough at this point, due to the relative simplicity of the library interface. 

XIII. SOURCE CODE 
Since our project is primarily focused on programming, source code printouts for the library itself and the server that goes together with the library are included at the end of the report, as per task specification for the term project. We infer, from the same task specification, that since source code is listed as part of the report itself, it counts towards 10-12 page limit mentioned later in the task specification. Hence we apologize in advance for exceeding 12 page limit, since we do have a habit of writing a lot of comments in our sources, and delimiting blocks of code belonging together by blank lines. 

ACKNOWLEDGMENT 

The authors would like to thank Dr. Hui Liu, our professor for the Computer Networking class. 

REFERENCES
[1] Eliya Buyukkaya and Maha Abdallah, Data Management in Voronoi-based P2P Gaming. Université Paris 6, Paris, France: Laboratoire d’Informatique de Paris 6.
[2] Eliya Buyukkaya, Maha Abdallah and Romain Cavagna et al, VoroGame: A Hybrid P2P Architecture for Massively Multiplayer Games. Université Paris 6, Paris, France: Laboratoire d’Informatique de Paris 6.
